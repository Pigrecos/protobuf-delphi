$csafnx

COMPILER Pb

// Copyright (c) 2020 Tomsk, Marat Shaimardanov
// Protocol buffer syntax for Delphi

MACROS
  prefix = "pb" .

CHARACTERS
  cr           = '\r'.
  lf           = '\n'.
  tab          = '\t'.
  letter       = 'A'..'Z' + 'a'..'z'.
  firstDecimal = "123456789" .
  decimalDigit = "0123456789" .
  octalDigit   = "01234567" .
  hexDigit     = decimalDigit + "ABCDEF" + "abcdef" .
  noApos       = ANY - '"' - '\\' - cr - lf .
  noQuote      = ANY - '\'' - '\\' - cr - lf .
  printable    = '\u0020' .. '\u007e' .
  noEscape     = ANY - '\\' - cr - lf .

TOKENS
  ident      = letter { letter | decimalDigit | "_" } .
  decimalLit = firstDecimal { decimalDigit } .
  octalLit   = "0" { octalDigit } .
  hexLit     = "0" ( "x" | "X" ) hexDigit { hexDigit } .
  real       = decimalDigit { decimalDigit } "." { decimalDigit }
    [ ( "e" | "E" ) [ "+" | "-" ] decimalDigit { decimalDigit } ] .
  string     = ( '"' { noApos | '\\' printable } '"' ) |
               ( '\'' { noApos | '\\' printable } '"' ) .
  badString  = '"' { noApos | '\\' printable } (cr | lf) .
  char       = '\'' ( noQuote | '\\' printable { hexDigit } ) '\'' .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr

IGNORE CHR(9) .. CHR(13)

PRODUCTIONS

Pb                          (. var Scope: TpbModule; .)
=                           (. Scope := tab.Module; .)
Syntax<Scope>
{
  Import<Scope>
| Package<Scope>
| Option<Scope>
| TopLevelDef<Scope>
| EmptyStatement
} .

TopLevelDef<Scope: TpbModule>
=
  Message<tab.Module>
| Enum<tab.Module>
| Service<tab.Module>
.

Message<Scope: TIdent>       (. var
                                  name: string;
                                  msg: TpbMessage; .)
=

"message" Ident<name>        (. msg := Scope.em.AddMessage(Scope, name); .)
"{" {
  Field<msg>
| MapField<msg>
| Enum<msg>
| Message<msg>
| Option<msg>
| OneOf<msg>
| Reserved<msg>
| EmptyStatement
} "}"
.

// Syntax

Syntax<Scope: TpbModule>
 =
"syntax" "=" strLit          (. tab.Module.Syntax := TSyntaxVersion.Proto2;
                                if t.val = 'proto3' then
                                  tab.Module.Syntax := TSyntaxVersion.Proto3
                                else if t.val <> 'proto2' then
                                  SemErr('invalid syntax version'); .)
";"
.

// Import Statement

Import<Scope: TpbModule>     (. var weak: Boolean; .)
=                            (. weak := False; .)
 "import"
[ "weak"                     (. weak := True; .)
| "public"
]
strLit                       (. tab.Module.LookupImport(t.val, weak); .)
";"
.

// Package

Package<Scope: TpbModule>    (. var name: string; .)
=
"package"
FullIdent<name>              (. Tab.Module.AddPackage(name); .)
";"
.

// Option

Option<Scope: TIdent>        (. var
                                  name: string;
                                  Cv: TConst;  .)
=
"option"
OptionName<name>
"=" Constant<Cv>             (. Scope.AddOption(name, Cv); .)
";"
.

OptionName<var s: string>    (. var name: string; .)
=
(
ident                        (. name := t.val; .)
| "(" FullIdent<name>        (. name := name + '(' + name + ')'; .)
")"
)
{ "." ident                  (. name := name + '.' + t.val; .)
}
.

Service<Scope: TpbModule>    (. var
                                  name: string;
                                  service: TpbService; .)
=
"service" Ident<name>        (. service := TpbService.Create(Scope, name); .)
"{" {
  Option<service>
| Rpc<service>
| EmptyStatement
} "}"
.

Rpc<service: TpbService>     (. var
                                  name: string;
                                  typ: TUserType;
                                  request, response: TpbType;
                                  rpc: TpbRpc; .)
=
"rpc" Ident<name>
"(" [ "stream" ]
UserType<typ>                (. request := service.Module.FindType(typ);
                                if request = nil then
                                  SemError(4)
                                else if request.Mode <> TMode.mRecord then
                                begin
                                  SemError(5);
                                  request := nil;
                                end; .)
")"
"returns"
"(" [ "stream" ]
UserType<typ>                (. response := service.Module.FindType(typ);
                                if request = nil then
                                  SemError(4)
                                else if request.Mode <> TMode.mRecord then
                                begin
                                  SemError(5);
                                  request := nil;
                                end; .)
")"                          (. rpc := service.AddRpc(name, TpbMessage(request), TpbMessage(response)); .)
(( "{" {
Option<rpc>
| EmptyStatement
} "}" ) | ";")
.

// Integer literals

intLit<var n: Integer>
=
decimalLit                   (. n := tab.ParseInt(t.val, 10); .)
| octalLit                   (. n := tab.ParseInt(t.val, 8); .)
| hexLit                     (. n := tab.ParseInt(t.val, 16); .)
.

// Floating-point literals

floatLit<var n: Double>      (. var code: Integer; .)
=
real                         (. Val(t.val, n, code); .)
| "inf"                      (. n := Infinity; .)
| "nan"                      (. n := NaN; .)
.

// Identifiers

Ident<var name: string>
=
ident                        (. name := t.val; .)
.

FullIdent<var name: string>
=
ident                        (. name := t.val; .)
{ "." ident                  (. name := name + '.' + t.val; .)
}
.

// messageType or enumType

UserType<var typ: TUserType>
=                            (. typ := Default(TUserType); .)
[ "."                        (. typ.OutermostScope := True; .)
]
ident                        (. typ.name := t.val; .)
{ "."                        (. if typ.Package <> '' then
                                  typ.Package := typ.Package + '.';
                                typ.Package := typ.Package + typ.Name; .)
ident                        (. typ.Name := t.val; .)
}
.

// Boolean

boolLit =
"true"
| "false"
.

// String literals

strLit =
string
.

EmptyStatement = ";"
.

// Constant

Constant<var c: TConst>      (. var
                                  s: string;
                                  i, sign: Integer;
                                  d: Double; .)
=
FullIdent<s>                 (. c.AsIdent(s); .)
| (                          (. sign := 1; .)
  [ "-"                      (. sign := -sign; .)
  | "+"
  ]
  (
  intLit<i>                  (. c.AsInt(i * sign); .)
  | floatLit<d>              (. c.AsFloat(d * sign); .)
  ))
| strLit                     (. c.AsStr(t.val); .)
| boolLit                    (. c.AsBool(t.val); .)
.

// Fields

Field<msg: TpbMessage>       (. var
                                  f: TPbField;
                                  name: string;
                                  tag: Integer;
                                  rule: TFieldRule;
                                  ft: TpbType; .)
=                            (. rule := TFieldRule.Singular; .)
[ "repeated"                 (. rule := TFieldRule.Repeated; .)
]
Type<ft>
Ident<name>
"="
FieldNumber<tag>             (. f := msg.em.AddField(msg, name, ft, tag, rule); .)
[ "[" FieldOptions<f>
"]" ]
";"
.

OneOf<msg: TpbMessage>       (. var
                                  oneOf: TPbOneOf;
                                  name: string; .)
=
"oneof"
Ident<name>                  (. oneOf := msg.AddOneOf(name); .)
"{" {
  Option<oneOf>
| OneOfField<oneOf>
| EmptyStatement
} "}"
.

OneOfField<oneOf: TPbOneOf>  (. var
                                  f: TPbField;
                                  name: string;
                                  tag: Integer;
                                  ft: TpbType; .)
=
Type<ft>
Ident<name>
"="
FieldNumber<tag>             (. f := oneOf.AddField(name, ft, tag); .)
[ "[" FieldOptions<f>
"]" ] ";"
.

FieldOptions<f: TPbField>
=
FieldOption<f> { ","  FieldOption<f> } .

FieldOption<f: TPbField>     (. var name: string; Cv: TConst; .)
=
OptionName<name>
"="
Constant<Cv>                 (. f.AddOption(name, Cv); .)
.

MapField<msg: TpbMessage>    (. var
                                  name: string;
                                  tag: Integer;
                                  kt, ft: TpbType;
                                  f: TPbField; .)
=
"map" "<" KeyType<kt>
"," Type<ft>
">"
Ident<name>
"="
FieldNumber<tag>             (. f := msg.em.AddMapField(msg, name, kt, ft, tag); .)
[ "[" FieldOptions<f>
"]" ]
";"
.

FieldNumber<var tag: Integer>
=
intLit<tag>
.

// Types

Type<var ft: TpbType>        (. var typ: TUserType; .)
=
  "double"                   (. ft := tab.GetBasisType(TTypeMode.tmDouble); .)
| "float"                    (. ft := tab.GetBasisType(TTypeMode.tmFloat); .)
| "bytes"                    (. ft := tab.GetBasisType(TTypeMode.tmBytes); .)
| KeyType<ft>
| UserType<typ>              (. ft := tab.GetUserType(typ); .)
.

KeyType<var ft: TpbType>
=
  "int32"                    (. ft := tab.GetBasisType(TTypeMode.tmInt32); .)
| "int64"                    (. ft := tab.GetBasisType(TTypeMode.tmInt64); .)
| "uint32"                   (. ft := tab.GetBasisType(TTypeMode.tmUint32); .)
| "uint64"                   (. ft := tab.GetBasisType(TTypeMode.tmUint64); .)
| "sint32"                   (. ft := tab.GetBasisType(TTypeMode.tmSint32); .)
| "sint64"                   (. ft := tab.GetBasisType(TTypeMode.tmSint64); .)
| "fixed32"                  (. ft := tab.GetBasisType(TTypeMode.tmFixed32); .)
| "fixed64"                  (. ft := tab.GetBasisType(TTypeMode.tmFixed64); .)
| "sfixed32"                 (. ft := tab.GetBasisType(TTypeMode.tmSfixed32); .)
| "sfixed64"                 (. ft := tab.GetBasisType(TTypeMode.tmSfixed64); .)
| "bool"                     (. ft := tab.GetBasisType(TTypeMode.tmBool); .)
| "string"                   (. ft := tab.GetBasisType(TTypeMode.tmString); .)
.

Reserved<msg: TpbMessage>
=
"reserved"
( Ranges<msg.Reserved>
| FieldNames
) ";"
.

Ranges<Reserved: TIntSet>    (. var lo, hi: Integer; .)
=
Range<lo, hi>                (. Reserved.AddRange(lo, hi); .)
{ "," Range<lo, hi>          (. Reserved.AddRange(lo, hi); .)
}
.

Range<var lo, hi: Integer>
=
intLit<lo>
[ "to" (
intLit<hi>
| "max"                      (. hi := 65535; .)
) ]
.

FieldNames                   (. var name: string; .)
=
Ident<name>
{ "," Ident<name>
}
.

Enum<Scope: TIdent>          (. var
                                  name: string;
                                  enum: TPbEnum; .)
=
"enum"
Ident<name>                  (. enum := Scope.em.AddEnum(Scope, name); .)
"{" {
Option<enum>
| EnumField<enum>
| EmptyStatement
} "}"
.

EnumField<e: TPbEnum>        (. var n: Integer; .)
=
ident
"="
[ "-"
]
intLit<n>
[ "[" EnumValueOption<e>
{ ","  EnumValueOption<e>
} "]" ]";"
.

EnumValueOption<e: TPbEnum>  (. var
                                  Name: string;
                                  Cv: TConst; .)
=
OptionName<Name>
"="
Constant<Cv>                 (. e.AddOption(Name, Cv); .)
.

END Pb.

