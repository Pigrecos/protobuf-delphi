$csafnx

COMPILER Pb

// Copyright (c) 2020 Tomsk, Marat Shaimardanov
// Protocol buffer syntax for Delphi

MACROS
  prefix = "pb" .

CHARACTERS
  cr           = '\r'.
  lf           = '\n'.
  tab          = '\t'.
  letter       = 'A'..'Z' + 'a'..'z'.
  firstDecimal = "123456789" .
  decimalDigit = "0123456789" .
  octalDigit   = "01234567" .
  hexDigit     = decimalDigit + "ABCDEF" + "abcdef" .
  noApos       = ANY - '"' - '\\' - cr - lf .
  noQuote      = ANY - '\'' - '\\' - cr - lf .
  printable    = '\u0020' .. '\u007e' .
  noEscape     = ANY - '\\' - cr - lf .

TOKENS
  ident      = letter { letter | decimalDigit | "_" } .
  decimalLit = firstDecimal { decimalDigit } .
  octalLit   = "0" { octalDigit } .
  hexLit     = "0" ( "x" | "X" ) hexDigit { hexDigit } .
  real       = decimalDigit { decimalDigit } "." { decimalDigit }
    [ ( "e" | "E" ) [ "+" | "-" ] decimalDigit { decimalDigit } ] .
  string     = ( '"' { noApos | '\\' printable } '"' ) |
               ( '\'' { noApos | '\\' printable } '"' ) .
  badString  = '"' { noApos | '\\' printable } (cr | lf) .
  char       = '\'' ( noQuote | '\\' printable { hexDigit } ) '\'' .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr

IGNORE CHR(9) .. CHR(13)

PRODUCTIONS

Pb                          (. var Scope: TpbModule; .)
=                           (. Scope := tab.Module; .)
Syntax<Scope>
{
  Import<Scope>
| Package<Scope>
| Option<Scope>
| TopLevelDef<Scope>
| EmptyStatement
} .

TopLevelDef<Scope: TpbModule>
=
  Message<tab.Module>
| Enum<tab.Module>
| Service<tab.Module>
.

Message<Scope: TIdent>       (. var
                                  name: string;
                                  msg: TpbMessage; .)
=

"message" Ident<name>        (. msg := Scope.em.AddMessage(name); .)
MessageBody<msg>
.

MessageBody<msg: TpbMessage>
=
"{" {
  Field<msg>
| MapField
| Enum<msg>
| Message<msg>
| Option<msg>
| OneOf<msg>
| Reserved
| EmptyStatement
} "}"
.

// Syntax

Syntax<Scope: TpbModule>
 =
"syntax" "=" strLit          (. tab.Module.Syntax := TSyntaxVersion.Proto2;
                                if t.val = 'proto3' then
                                  tab.Module.Syntax := TSyntaxVersion.Proto3
                                else if t.val <> 'proto2' then
                                  SemErr('invalid syntax version'); .)
";"
.

// Import Statement

Import<Scope: TpbModule>     (. var weak: Boolean; .)
=                            (. weak := False; .)
 "import"
[ "weak"                     (. weak := True; .)
| "public"
]
strLit                       (. tab.Module.LookupImport(t.val, weak); .)
";"
.

// Package

Package<Scope: TpbModule>    (. var Name: string; .)
=
"package"
FullIdent<Name>              (. Tab.Module.AddPackage(Name); .)
";"
.

// Option

Option<Scope: TIdent>        (. var
                                  Name: string;
                                  Cv: TConst;  .)
=
"option"
OptionName<Name>
"=" Constant<Cv>             (. Scope.AddOption(Name, Cv); .)
";"
.

OptionName<var s: string>    (. var name: string; .)
=
(
ident                        (. name := t.val; .)
| "(" FullIdent<name>        (. name := name + '(' + name + ')'; .)
")"
)
{ "." ident                  (. name := name + '.' + t.val; .)
}
.

Service<Scope: TpbModule>    (. var
                                  name: string;
                                  service: TpbService; .)
=
"service" Ident<name>        (. service := TpbService.Create(Scope, name); .)
"{" {
  Option<service>
| Rpc<service>
| EmptyStatement
} "}"
.

Rpc<service: TpbService>
=
"rpc" Ident<name>
"("
[ "stream"
]
UserType<messageType>
")"
"returns"
"(" [ "stream" ]
UserType<messageType>
")"
(( "{" {
Option<rpc>
| EmptyStatement
} "}" ) | ";")
.

// Integer literals

intLit<var s: string>
=
decimalLit                   (. s := t.val; .)
| octalLit                   (. s := t.val; .)
| hexLit                     (. s := t.val; .)
.

// Floating-point literals

floatLit<var s: string>
=
real                         (. s  := t.val; .)
| "inf"                      (. s := 'Infinity'; .)
| "nan"                      (. s := 'NaN'; .)
.

// Identifiers

Ident<var name: string>
=
ident                        (. name := t.val; .)
.

FullIdent<var name: string>
=
ident                        (. name := t.val; .)
{ "." ident                  (. name := name + '.' + t.val; .)
}
.

// messageType or enumType

UserType<var typ: string>    (. .)
=
[ "."
]
ident
{ "." ident
}
.

// Boolean

boolLit =
"true"
| "false"
.

// String literals

strLit =
string
.

EmptyStatement = ";"
.

// Constant

Constant<var c: TConst>      (. var cval: string; .)
=
FullIdent<cval>              (. c.Init(cval, TConstType.cIdent); .)
| (
  [ "-"                      (. c.sign := -1; .)
  | "+"
  ]
  (
  intLit<cval>               (. c.Init(cval, TpbConstant.cInt); .)
  | floatLit<cval>           (. c.Init(cval, TpbConstant.cFloat); .)
  ))
| strLit                     (. c.Init(t.val, TpbConstant.cStr); .)
| boolLit                    (. c.Init(t.val, TpbConstant.cBool); .)
.

// Fields

Type<f: TPbField>
=
  "double"
| "float"
| "int32"
| "int64"
| "uint32"
| "uint64"
| "sint32"
| "sint64"
| "fixed32"
| "fixed64"
| "sfixed32"
| "sfixed64"
| "bool"
| "string"
| "bytes"
| UserType<typ>
.

FieldNumber<var fn: string>
=
intLit<fn>
.

Field<msg: TpbMessage>       (. var f: TPbField; .)
=
[ "repeated"
]
Type<f>
Ident<fieldName>
"="
FieldNumber<f.FieldNumber>
[ "[" FieldOptions<f>
"]" ] ";"
.

OneOf<msg: TpbMessage>       (. var oneOf: TPbOneOf; .)
=
"oneof"
Ident<oneofName>
"{" {
  Option<oneOf>
| OneOfField<oneOf>
| EmptyStatement
} "}"
.

OneOfField<oneOf: TPbOneOf>  (. var f: TPbField; .)
=
Type<f>
Ident<f.fieldName>
"="
FieldNumber<f.FieldNumber>
[ "[" FieldOptions<f>
"]" ] ";"
.

FieldOptions<f: TPbField>
=
FieldOption<f>
{ ","  FieldOption<f>
}
.

FieldOption<f: TPbField>     (. var Name: string; Cv: TConst; .)
=
OptionName<option.Name>
"="
Constant<Cv>                  (. f.AddOption(Name, Cv); .)
.

MapField                     (. var f: TPbField; .)
=
"map" "<" keyType
"," Type<f>
">"
Ident<mapName>
"="
FieldNumber<f.FieldNumber>
[ "[" FieldOptions<f>
"]" ] ";"
.

keyType
=
"int32"
| "int64"
| "uint32"
| "uint64"
| "sint32"
| "sint64"
| "fixed32"
| "fixed64"
| "sfixed32"
| "sfixed64"
| "bool"
| "string"
.

Reserved
=
"reserved"
( Ranges
| FieldNames
) ";"
.

Ranges                       (. var lo, hi: string; .)
=
Range<lo, ho>
{ "," Range<lo, hi>
}
.

Range<var lo, hi: string>
=
intLit<lo>
[ "to" (
intLit<hi>
| "max"                      (. hi := 'max'; .)
) ]
.

FieldNames
=
Ident<fieldName>
{ "," Ident<fieldName>
}
.

Enum<Scope: TIdent>          (. var
                                  name: string;
                                  enum: TPbEnum; .)
=
"enum"
Ident<name>                  (. enum := Scope.em.AddEnum(name); .)
EnumBody<enum>
.

EnumBody<enum: TPbEnum>
=
"{" {
Option<enum>
| EnumField<enum>
| EmptyStatement
} "}"
.

EnumField<e: TPbEnum>        (. var n: string; .)
=
ident
"="
[ "-"
]
intLit<n>
[ "[" EnumValueOption<e>
{ ","  EnumValueOption<e>
} "]" ]";"
.

EnumValueOption<e: TPbEnum>  (. var Name: string; Cv: TConst; .)
=
OptionName<Name>
"="
Constant<Cv>                 (. e.AddOption(Name, Cv); .)
.

END Pb.

