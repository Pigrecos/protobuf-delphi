$csafnx

COMPILER Pb

// Copyright (c) 2020 Tomsk, Marat Shaimardanov
// Protocol buffer syntax for Delphi

MACROS
  prefix = "pb" .

CHARACTERS
  cr           = '\r'.
  lf           = '\n'.
  tab          = '\t'.
  letter       = 'A'..'Z' + 'a'..'z'.
  firstDecimal = "123456789" .
  decimalDigit = "0123456789" .
  octalDigit   = "01234567" .
  hexDigit     = decimalDigit + "ABCDEF" + "abcdef" .
  noApos       = ANY - '"' - '\\' - cr - lf .
  noQuote      = ANY - '\'' - '\\' - cr - lf .
  printable    = '\u0020' .. '\u007e' .
  noEscape     = ANY - '\\' - cr - lf .

TOKENS
  ident      = letter { letter | decimalDigit | "_" } .
  decimalLit = firstDecimal { decimalDigit } .
  octalLit   = "0" { octalDigit } .
  hexLit     = "0" ( "x" | "X" ) hexDigit { hexDigit } .
  real       = decimalDigit { decimalDigit } "." { decimalDigit }
    [ ( "e" | "E" ) [ "+" | "-" ] decimalDigit { decimalDigit } ] .
  string     = ( '"' { noApos | '\\' printable } '"' ) |
               ( '\'' { noApos | '\\' printable } '"' ) .
  badString  = '"' { noApos | '\\' printable } (cr | lf) .
  char       = '\'' ( noQuote | '\\' printable { hexDigit } ) '\'' .

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO cr

IGNORE CHR(9) .. CHR(13)

PRODUCTIONS

Pb =
Syntax {
Import
| Package
| Option
| TopLevelDef
| EmptyStatement
} .

// Syntax

Syntax                       (. var s: string; .)
 =
"syntax" "=" strLit          (. s := t.val;
                                tab.Syntax := TSyntaxVersion.Proto2;
                                if s = 'proto3' then
                                  tab.Syntax := TSyntaxVersion.Proto3
                                else if s <> 'proto2' then
                                  SemErr('invalid syntax version'); .)
";"
.

// Import Statement

Import                       (. var import: TpbImport; .)
=
 "import"
[ "weak"                     (. import.weak := True; .)
| "public"                   (. import.publ := True; .)
]
strLit                       (. import.Name := t.val;
                                Tab.AddImport(import); .)
";"
.

// Package

Package                      (. var p: TpbPackage; .)
=
"package"
FullIdent<p.Name>            (. Tab.AddPackage(p); .)
";"
.

// Option

Option                       (. var option: TpbOption; .)
=
"option"
OptionName<option.Name>
"=" Constant                 (. Tab.AddOption(option); .)
";"
.

OptionName<var s: string>    (. var name: string; .)
=
(
ident                        (. name := t.val; .)
| "(" FullIdent<name>        (. name := name + '(' + name + ')'; .)
")"
)
{ "." ident                  (. name := name + '.' + t.val; .)
}
.

TopLevelDef
=
Message
| Enum
| service
.

Message                      (. var msg: TpbMessage; .)
=
"message" Ident<msg.Name>
MessageBody                  (. Tab.AddOption(option); .)
.

MessageBody
=
"{" {
Field
| Enum
| Message
| Option
| oneof
| mapField
| Reserved
| EmptyStatement
} "}"
.

service
=
"service" Ident<serviceName>
"{" {
Option
| rpc
| EmptyStatement
} "}"
.

rpc
=
"rpc" Ident<name>
"("
[ "stream"
]
userType<messageType>
")"
"returns"
"(" [ "stream" ]
userType<messageType>
")"
(( "{" {
Option
| EmptyStatement
} "}" ) | ";")
.

// Integer literals

intLit<var s: string>
=
decimalLit                   (. s := t.val; .)
| octalLit                   (. s := t.val; .)
| hexLit                     (. s := t.val; .)
.

// Floating-point literals

floatLit<var s: string>
=
real                         (. s  := t.val; .)
| "inf"                      (. s := 'Infinity'; .)
| "nan"                      (. s := 'NaN'; .)
.

// Identifiers

Ident<var name: string>
=
ident                        (. name := t.val; .)
.

FullIdent<var name: string>
=
ident                        (. name := t.val; .)
{ "." ident                  (. name := name + '.' + t.val; .)
}
.

// messageType or enumType

userType<var typ: string>
=
[ "."
]
ident
{ "." ident
}
.

// Boolean

boolLit =
"true"
| "false"
.

// String literals

strLit =
string
.

EmptyStatement = ";"
.

// Constant

Constant                     (. var c: TpbConstant; .)
=                            (. c.Init; .)
FullIdent<c.name>
| (
  [ "-"                      (. c.sign := -1; .)
  | "+"
  ]
  (
  intLit<c.val>              (. c.kind := TpbConstant.cInt; .)
  | floatLit<c.val>          (. c.kind := TpbConstant.cFloat; .)
  ))
| strLit                     (. c.kind := TpbConstant.cStr; c.val := t.val; .)
| boolLit                    (. c.kind := TpbConstant.cBool; c.val := t.val; .)
.

// Fields

type =
"double"
| "float"
| "int32"
| "int64"
| "uint32"
| "uint64"
| "sint32"
| "sint64"
| "fixed32"
| "fixed64"
| "sfixed32"
| "sfixed64"
| "bool"
| "string"
| "bytes"
| userType<typ>
.

FieldNumber<var fn: string>
=
intLit<fn>
.

Field                        (. var f: TPbField; .)
=
[ "repeated"
]
type
Ident<fieldName>
"="
FieldNumber<f.FieldNumber>
[ "[" FieldOptions
"]" ] ";"
.

oneof
=
"oneof"
Ident<oneofName>
"{" {
Option
| oneofField
| EmptyStatement
} "}"
.

oneofField =                 (. var f: TPbField; .)
type
Ident<fieldName>
"="
FieldNumber<f.FieldNumber>
[ "[" FieldOptions
"]" ] ";"
.

FieldOptions
=
FieldOption
{ ","  FieldOption
}
.

FieldOption                  (. var option: TOption; .)
=
OptionName<option.Name>
"="
Constant                     (. Tab.AddOption(option); .)
.

mapField                     (. var f: TPbField; .)
=
"map" "<" keyType
"," type
">"
Ident<mapName>
"="
FieldNumber<f.FieldNumber>
[ "[" FieldOptions
"]" ] ";"
.

keyType
=
"int32"
| "int64"
| "uint32"
| "uint64"
| "sint32"
| "sint64"
| "fixed32"
| "fixed64"
| "sfixed32"
| "sfixed64"
| "bool"
| "string"
.

Reserved
=
"reserved"
( Ranges
| FieldNames
) ";"
.

Ranges                       (. var lo, hi: string; .)
=
Range<lo, ho>
{ "," Range<lo, hi>
}
.

Range<var lo, hi: string>
=
intLit<lo>
[ "to" (
intLit<hi>
| "max"                      (. hi := 'max'; .)
) ]
.

FieldNames
=
Ident<fieldName>
{ "," Ident<fieldName>
}
.

Enum
=
"enum"
Ident<name>
EnumBody
.

EnumBody
=
"{" {
Option
| EnumField
| EmptyStatement
} "}"
.

EnumField                     (. var n: string; .)
=
ident
"="
[ "-"
]
intLit<n>
[ "[" EnumValueOption
{ ","  EnumValueOption
} "]" ]";"
.

EnumValueOption              (. var option: TOption; .)
 =
OptionName<option.Name>
"="
Constant                     (. Tab.AddOption(option); .)
.

END Pb.

